## 2.02 构建: webpack

官网: <https://www.webpackjs.com/concepts/>   

##### 1. 安装使用

```
$ npm install -g webpack webpack-cli
$ npm install webpack webpack-cli --save-dev  //局部也要安装

webpack是webpack的核心代码
webpack-cli是提供webpack命令

$ webpack <entry> <output>   // 单文件打包
```

##### 2. 4+1核心概念
webpack处理应用程序时，会递归的构建一个依赖关系图，将所有依赖的模块打包成一个或多个bundle。

```
1、入口 entry
指示使用哪个模块(文件), 作为构建其内部依赖图的开始入口


2、出口 output
告诉 webpack 将打包好的资源 bundles 输出到哪里，以及如何命名


3、预处理 loder
webpack 核心只处理js已经json化的文件，非js文件交给loader处理。
npm install --save-dev css-loader
npm install --save-dev ts-loader
配置（推荐）：在 webpack.config.js 文件中指定 loader
内联：在每个 import 语句中显式指定 loader
CLI：在 shell 命令中指定它们


4、插件 plugins
用于执行范围更广，功能更多的任务，比如打包优化、压缩、定义环境变量等等


5、模块 module
告诉webpack，在不同模式下使用不同的配置，主要有开发模式和生产模式
a. 开发环境development,为了调试,不会对打包后的代码进行压缩，并热更新
b. 生产环境production,为了上线的性能, 会将打包后的代码进行压缩

```

```
const HtmlWebpackPlugin = require('html-webpack-plugin');  // 4、插件

const config = {
    entry : 'index.js',    // 1、入口文件
    output: {
        filename: 'handle.js',    // 2、输出的文件名
        path: resolve(__dirname,'dist')  // 2、输出文件路径
    },
    module: {  
        rules: [  
            {
                test: /\.css&/,   // 3、正则匹配
                use: 'css-loader'   // 3、当遇到.css结尾文件，使用css-loader转成js能识别的模块
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin();  // 4、插件引用
    ],
    mode: 'production',   // 5、模式   还有development
}

module.exports = config;
```

##### 3. 模块解析

```
1、解析
resolver是一个库(library)，用于帮助找到 bundle 中需要引入的模块代码
引用方式一：import foo from 'path/to/module'     
引用方式二：require('path/to/module')           

2、解析规则
绝对路径：import "/home/me/file";
相对路径：import "../src/file1";
模块路径：
import "module";     
import "module/lib/file";     
模块将在 resolve.modules 中指定的所有目录内搜索


```

##### 4. manifest
```
webpack 构建的典型应用中，主要有三种主要代码类型：
1、你或你的团队编写的源码
2、依赖于第三方library和vendor的源码
3、webpack的runtime和manifest，管理所有模块交互的

runtime：
在模块交互时，连接模块所需的加载和解析逻辑

manifest：
一旦index.html、bundle、各种资源加载到浏览器，那精心安排的/src目录结构将不存在，
那webpack如何管理所有模块之间的交互(调用)呢？

编译器执行、解析、映射时，会保留所有详细要点，这个数据集合为manifets。
打包发送到浏览器，通过manifest里的数据，runtime能够查询模块标识符，检索出背后的映射模块

```

##### 5. 构建目标targets
因为服务器和浏览器都可以用js编写，所以webpack提供了多种构建目标(target)配置
```
// vim webpack.config.js
var path = require('path');
var serverConfig = {
  target: 'node',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.node.js'
  }
  //…
};

var clientConfig = {
  target: 'web', // <=== 默认是 'web'，可省略
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.js'
  }
  //…
};

module.exports = [ serverConfig, clientConfig ];
```

##### 6. 模块热更新
模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面
```
加快开发速度的方式：
1、保留在完全重新加载页面时丢失的应用状态
2、只更新变更内容
3、调整样式加快速度


```