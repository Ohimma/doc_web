## 2.03 实例 各类属性

开发中，我们经常要通过一些函数，封装一些方法来调用实现目的

##### 1. 数据属性 data

vue的数据是写在 vue实例(选项)对象的data属性中，通过Mustache模板语法(双大括号)，把数据插入到页面    

```
<div id="app">
    {{ msg1 }} 
    {{ msg2 }} 
</div>
<script>
    let vm = new Vue({
      el:'#app',
      data:{
        msg1:'hello msg1',
        msg2:["hello","msg2"],
      }
    })
</script>


特点：     
1. js 输出数组时，会显示[object object]，而 vue 会直接输出 json 编码后的值
2. 调试时将内容渲染到页面，比将数据输出到控制台更加有效果
3. 页面会随着值得变化而变化(响应式)
```

###### 1. 普通数据响应式
```
为什么值改变页面会发生变化？
1、vue 实例化时，data 对象中的所有属性就会加入到 vue 的响应系统 
2、get/set 方法就是 vue 响应系统的函数方法
3、get/set 方法就会一直监听该数据，并根据值的变化做出响应，改变视图

4、data 对象中初始化的对象才能被响应，新加的数据不能 (建议即使不使用也初始化进去)
5、Object.freeze() 是冻结方法，即不允许修改对象的属性值，也不会触发响应系统
```

###### 2. 对象数据响应式
```
1、实例化 vue 之前，定义好的对象以及对象中的属性都会被响应系统监听
2、新增的对象属性不会被检测响应

如何让新增的对象属性被监听？
1、使用 vm.$set(vm.msg_obj, "sex", "男")【量多的时候不好】
2、直接替换整个对象 vm.msg_obj={name: "aaa", txt: "txt"}【对象中属性很多时太麻烦】
3、采用对象的方法添加 vm.msg_obj = Object.assign({}, vm.msg_obj, {ass: "true"}) 

```

###### 3. 数组数据响应式
测试过程，感觉新版本的 vue 不是用以下方法也可以监听到 list 变动

```
数组渲染到页面，虽然可以更改数组的内容，但是无法触发vue响应系统 

如何让数组的属性被监听？
变异方法(即更改原数组)
push()
pop()
shift()
unshift()
splice()
sort()
reverse()

非变异方法(即不会更改原数组)
filter()
concat()
slice()

```


###### 4. 示例
 
![](../_static/vue_02_05-1.png)

```
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"></script>
    <div id="app">
        <p>{{ msg }}</p> 
        <p>{{ msg_obj }}</p> 
        <p>{{ msg_list }}</p> 
    </div>
    
    <script>
        var freeze_msg = {foo: 'bar'}
        Object.freeze(freeze_msg)
        let vm = new Vue({
          el:'#app',
          data:{
            msg: 'hello msg1',
            msg_obj: {name:'jack', age: 18},
            msg_list: ["hello","list"],
            msg_freeze: freeze_msg,
          }
        })

        setTimeout(() => {
            vm.$data.msg = "bye world" 
            vm.msg_obj.name = "小明";
            vm.msg_obj = Object.assign({}, vm.msg_obj, {ass: "true"}) //会加入到响应系统
            vm.msg_obj.sex = "男"   // 不会加入到响应系统, 在assign前边就会引入进去
            vm.msg_list[3] = "3" 
            vm.msg_list.push(4)           
        }, 5000)

    </script>
</body>
</html>

```


##### 2. 方法属性 methods
开发中我们经常把一些复用的逻辑封装在函数里，调用执行。vue 中是用的是 方法属性

```
1、方法的调用 (mutache语法)
<div>{{ statusDoing(status) }}</div>


2、方法中this指向
方法中不能使用箭头函数，因为箭头函数中this指的是widows对象，不是vue实例对象

3、方法具有响应式作用

```

##### 3. 计算属性 computed
```
1、计算属性中的方法也是函数
2、每次调用时，实际调用vue实例上的属性，不会重新计算方法，实现缓存
3、vue初始化时会把计算属性和属性值添加到vue实例上被监听，不需要初始化调用
4、computed是方法是不是属性，方法是没有缓存的，他根据依赖处理逻辑对数据缓存

5、计算属性的 get和set
computed:{
     // 计算属性写成对象,就需要手动设置get方法,set方法
    sum:{
        get(){
            // 获取时调用的方法  
        },
        set(val){
                // 设置时调用
       }
    },
        
    // 如果计算属性写成函数,默认调用的就是get方法,没有set方法
     sum(){
     }
}

```

##### 4. 监听属性 watch
监听器是观察vue实例(属性)变化的一个表达式或者计算属性。         

```
1、watch的属性名必须和被观察人保持一致

2、监听函数接受(被传入)两个值，第一个是变化后的新值，第二个变化前的值

3、监听对象属性
默认监听器只会监听对象整体，想要监听对象内属性值怎么办？
解决一：需要用 . 操作符
解决二：使用深度监听 deep:true

深度监听后，我们发现获取到的新旧值都是新值？
因为对象是引用类型，要循着引用地址查找结果，当改变后地址也发生改变，查出来的值一样
解决一：采用computed计算属性，JSON.parse出两个地址


4、另一种方法监听
vm.$watch("msg",(val,newVal) => {console.log(val, newVal)})

5、另一种监听配置
vm.$watch("msg",(val,newVal) => {console.log(val, newVal)}, {deep: true})


```



##### 5. 过滤属性 filter

Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由"管道符"指示。
```
1、mustache 处理
<p>苹果价格:{{ (priceOne/100).toFixed(2) }} 元/斤</p>

2、方法处理
<p>苹果价格:{{ priceHandle(priceOne)}} 元/斤</p>

3、过滤器处理
<p>苹果价格:{{ priceOne | formatPrice}} 元/斤</p>

4、过滤器参数
过滤器默认将前边结果作为第一个参数，若还想加参数，可以加在括号里，作为第二个之后的参数

5、链式过滤器(即多了几个管道符)

6、全局过滤器
过滤器只能用在当前实例对象上，如果别的实例也想用，怎么办？
Vue.filter("formatPrice",function(price,symbol){
        return symbol+price.toFixed(2) +'元/斤'
})

7、过滤器不能使用this访问数据或者其他方法
8、过滤器只能 在插值或者v-bind指令中使用过滤器
```


##### 6. 对比

**计算属性 与 方法属性**          
1、methods属性里的函数是方法，每次执行都会调用，没有缓存      
2、computed属性里函数是属性，第一次计算后就会缓存        
3、computed属性里函数计算就是方法，不能加括号引用           
4、变化不频繁的用computed，变化频繁的用methods             

**计算属性 与 监听属性**      
计算属性computed和监听属性watch都可以做到对于数据的检测            
1、computed 监听的值我们需要用它，依赖变化运算过程          
2、watch 监听的值我们不需要用它，只是在他改变时做点事情



##### 7. 示例
![](../_static/vue_02_09-2.png)

```
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>txt</title>
    <style>
        #app div {
            width: 700px;
            
        }
        .box1 {
            height: 40px;
            background-color: lightcyan;
        }
        .box2 {
            height: 30px;
            background-color: pink;
        }
    </style>
</head>
<body>
    <script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"></script>

    <div id="app">

        <!-- mustache 模板来处理逻辑 -->
        <div>mustache形式: {{ msg.split("").reverse().join("") }}</div>
        
        <!-- 方法属性调用 处理代码逻辑 -->
        <div>方法属性形式: {{ reverseStr() }}</div>

        <!-- 计算属性调用 处理代码逻辑 -->
        <div>计算属性形式: {{ reverseStr2 }}</div>
    
        <!-- 过滤属性调用 处理代码逻辑 -->
        <div>过滤属性形式: {{ msg | reverseStr3() }}</div>

        <div><input type="text" v-model.number="msg1.name">监听属性(见console): {{ msg1 }}</div>

        <!-- 全选案例-->
        <div>
            全选: <input type="checkbox" v-model="checkAll">
        </div>
        <ul>
            <li
                v-for="fruit in fruits" 
                :key="fruit.title"
                >
                <input type="checkbox" v-model="fruit.isSelect">
                {{fruit.title}}: 价格{{fruit.price}}元/斤
            </li>
        </ul>

    </div>
    
    <script>  
        const vm = new Vue({
            el: "#app",
            data: {
                msg: 'hello',
                msg1: {name: 'jack', age: 20},
                fruits:[
                    {
                        title:"西瓜",
                        price: 10,
                        isSelect:false,
                    },
                    {
                        title:"苹果",
                        price: 22,
                        isSelect:false,
                    }
                ]
            },
            methods: {
                reverseStr(){
                    return this.msg.split("").reverse().join("")
                },
            },
            computed:{
                reverseStr2(){
                    return this.msg.split("").reverse().join("")
                },
                msg1(){
                    return JSON.parse(JSON.stringify(this.name));
                },
                checkAll:{
                    get(){
                        console.log("computed全选: 点击任意复选框")
                        // 如果用户全部选中,那么计算数据返回true,否则返回false
                        return this.fruits.every((fruit) => {
                            return fruit.isSelect;
                        })
                    },
                    set(isCheckAll){
                        // 更加用户是否点击全选改变数据里的选中问题
                        this.fruits.forEach(fruit => {
                            fruit.isSelect = isCheckAll
                        });
    
                    }
                }
            },
            filters:{
                reverseStr3(val){
                    console.log("filters val = ", val)
                    return val.split("").reverse().join("") 
                }
            },
            watch:{
                msg1:{// 此时 msg1 就是一个配置对象,里面的属性都是配置选项
                    // handler 就是原来的监听函数, 当数据变化是执行的函数
                    handler(val, oldval){
                        console.log("watch newval = ", val);
                        console.log("watch oldval = ", oldval);                
                    },
                    deep:true,     // 深度监听选项 
                    immediate: true, // 初始化就执行一次触发回调，从无到有
                }
            },
            
        })
    </script>
</body>
</html>
```
