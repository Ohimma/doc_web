## 3.022 HTML5 画布(canvas)

<canvas> 元素用于图形的绘制、照片集、动画，甚至对实时视频的处理。
<canvas> 标签只是图形容器，需要通过脚本 (通常是JavaScript)来完成。



##### 1. 语法

```
// 创建画布 (看起来和<img>类似，但只有两个 width/height 属性，默认宽300px、高150px。建议不要用css设置宽高)
<canvas id="tutorial" width="300" height="300"></canvas>

// 渲染上下文，现在重点研究 2d 对象
var canvas = document.getElementById('tutorial');
var ctx = canvas.getContext('2d');

```

##### 2. 绘制形状
三种方法：         
1、fillRect(x, y, width, height)     绘制一个填充的矩形             
2、strokeRect(x, y, width, height)   绘制一个矩形的边框
3、clearRect(x, y, widh, height)     清除指定的矩形区域，然后这块区域会变的完全透明              

x, y：指的是矩形的左上角的坐标，width, height：指的是绘制的矩形的宽和高 

##### 3. 绘制路径
图形的基本元素是路径。          

使用路径绘制图形需要一些额外的步骤：
1、beginPath()   新建一条路径    
2、moveTo(x, y)  创建路径起始点 
3、closePath()   闭合路径
4、stroke()      通过线条来绘制图形轮廓
4、fill()        通过填充路径内容区域生成实心图形

绘制圆弧两种方法：      
1、arc(x, y, r, startAngle, endAngle, anticlockwise) 
以(x, y) 为圆心，r为半径，从startAngle弧度开始到endAngle弧度结束。anticlosewise 是布尔值，true 表示逆时针，false 表示顺时针(默认是顺时针)        
Math.PI = 3.14 = 180度   // 角度转弧度         

2、arcTo(x1, y1, x2, y2, radius): 根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点

```
<body>
	<canvas id="tutorial0" width="150" height="150"></canvas>
    <canvas id="tutorial1" width="150" height="150"></canvas>
	<canvas id="tutorial2" width="150" height="150"></canvas>
    <canvas id="tutorial3" width="150" height="150"></canvas>
<script type="text/javascript">
	function draw0(){
        var canvas = document.getElementById('tutorial0');
        if(!canvas.getContext) return;
        var ctx = canvas.getContext("2d");
    	
    	ctx.fillRect(10, 10, 100, 50);   // 在x=10y=10地方绘制    100*50的矩形
    	
        ctx.strokeRect(10, 70, 100, 50);  // 在x=10y=70地方绘制    100*50的矩形
    	
    	ctx.clearRect(15, 15, 50, 25);    // 绘制清楚矩形，默认颜色    为白色
    }
    function draw1(){
        var canvas = document.getElementById('tutorial1');
        if(!canvas.getContext) return;
    	
        var ctx = canvas.getContext("2d");
    	
    	ctx.beginPath();     //新建一条path
        ctx.moveTo(30, 80);  //把画笔移动到指定的坐标
        ctx.lineTo(80, 80);  //绘制一条从当前位置到指定坐标(70, 50)的直线.
        ctx.closePath();     //闭合路径
        ctx.stroke();        //通过线条绘制路径。
    }
	function draw2(){
        var canvas = document.getElementById('tutorial2');
        if(!canvas.getContext) return;
    	
        var ctx = canvas.getContext("2d");
    	
    	ctx.beginPath();  
        ctx.moveTo(30, 50);
        ctx.lineTo(30, 100);
        ctx.lineTo(90, 100);
        ctx.fill();     //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径。
    }
	function draw3(){
        var canvas = document.getElementById('tutorial3');
        if(!canvas.getContext) return;
    	
        var ctx = canvas.getContext("2d");
    	
    	ctx.beginPath();
        ctx.arc(30, 50, 20, -Math.PI / 2, Math.PI / 2, false);
        ctx.stroke();    // 不闭合，-90度~90度，逆时针，线条绘制路径
     
        ctx.beginPath();
        ctx.arc(100, 50, 20, 0, Math.PI, true);
        ctx.closePath();  
        ctx.stroke();    // 闭合，0~180度，顺时针，线条绘制路径
     
        ctx.beginPath();
        ctx.arc(30, 100, 20, -Math.PI / 2, Math.PI / 2, false);
        ctx.fill();     // 不闭合，-90度~90度，逆时针，填充绘制
     
        ctx.beginPath();
        ctx.arc(100, 100, 20, 0, Math.PI, false);
        ctx.fill();     // 不闭合，0度~180度，逆时针，填充绘制
    }
	
	draw0();
    draw1();
	draw2();
	draw3();
</script>
</body>
```
![](../_static/html5_03_02-1.png)


##### 4. 添加样式和颜色
**颜色设置：**         
1、fillStyle = color   // 设置填充颜色(对标css),可以是渐变、rgba等     
2、strokeStyle = color // 设置轮廓颜色(对标css)      


**线条样式：**          
setLineDash[10, 2]   // 虚线 实线长10 间隙2           
lineDashOffset = -0  // 虚线 起始偏移量             
lineWidth = 10       // 默认是线的宽度1.0               

lineCaps = butt      // 线段末端以方形结束             
lineCaps = round     // 线段末端以圆形结束           
lineCaps = square    // 线段末端以方形结束             

lineJoin = round     // 线段连接处，圆形拐角         
lineJoin = bevel     // 线段连接处，矩形拐角          
lineJoin = miter     // 线段连接处，菱形拐角(默认)          


##### 5. 绘制文本
fillText(text,x,y [,maxWidth])  // 在 (x,y) 位置填充text，宽度可选           
strokeText(text,x,y[,maxWidth]) // 在(x,y) 位置绘制text边框，宽度可选         
font = value     // 绘制文本样式，默认的字体是 10px sans-serif

textAlign = value   // 文本对齐选项 start/end/left/right/center。默认值是 start。          
textBaseline = value  // 基线对齐选项，可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。      
direction = value    // 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。        

```
<body>
    <canvas id="tutorial1" width="150" height="150"></canvas>
	<canvas id="tutorial2" width="150" height="150"></canvas>
	<canvas id="tutorial3" width="150" height="150"></canvas>
	<canvas id="tutorial4" width="150" height="150"></canvas>
	
<script type="text/javascript">
    function draw1(){
        var canvas = document.getElementById('tutorial1');
        if (!canvas.getContext) return;
        ctx = canvas.getContext("2d");
		
        ctx.font = "30px sans-serif"
        ctx.fillText("天若有情", 10, 50);
        ctx.strokeText("天若有情", 10, 100)
    }
	function draw2(){
        var canvas = document.getElementById('tutorial2');
        if(!canvas.getContext) return;
        var ctx = canvas.getContext("2d");
    	
    	ctx.fillStyle = "rgba(200,0,0,0.5)"; // 绘制填充矩形，默认颜色为    黑色
    	ctx.fillRect(10, 10, 100, 50);       // 在x=10y=10地方绘制    100*50的矩形
    	ctx.clearRect(15, 15, 50, 25);    // 绘制清楚矩形，默认颜色    为白色
		
		ctx.setLineDash([10, 3]);         // [实线长度, 间隙长度]
        ctx.lineDashOffset = -0;
        ctx.strokeRect(10, 70, 100, 50);

    }
	function draw3(){
        var canvas = document.getElementById('tutorial3');
        if(!canvas.getContext) return;
        var ctx = canvas.getContext("2d");
    	
		var lineCaps = ["butt", "round", "square"];
		ctx.lineWidth = 20;
		
		for (var i = 0; i < 3; i++){
            ctx.beginPath();
            ctx.moveTo(30 + 30 * i, 30);
            ctx.lineTo(30 + 30 * i, 100);
            ctx.lineCap = lineCaps[i];
            ctx.stroke();
        }
    }
	function draw4(){
        var canvas = document.getElementById('tutorial4');
        if(!canvas.getContext) return;
        var ctx = canvas.getContext("2d");
    	
		var lineJoin = ['round', 'bevel', 'miter'];
        ctx.lineWidth = 20;
     
        for (var i = 0; i < lineJoin.length; i++){
            ctx.beginPath();
            ctx.moveTo(10, 20 + i * 40);
            ctx.lineTo(30, 50 + i * 40);
            ctx.lineTo(60, 20 + i * 40);
            ctx.lineTo(90, 50 + i * 40);
            ctx.lineTo(120, 20 + i * 40);
			ctx.lineJoin = lineJoin[i];
            ctx.stroke();
        }
    }
    draw1();
	draw2();
	draw3();
	draw4();
</script>
</body>
```
![](../_static/html5_03_02-2.png)



##### 6. 绘制图片
ctx.drawImage(img,x,y)   // 绘制img            
drawImage(image, x, y, width, height)   // width/height 缩放大小                
drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
// 前 4 个是定义图像源的切片位置和大小，后 4 个则是定义切片的目标显示位置和大小       


```
<img src="./美女.jpg" alt="" width="300"><br>
<canvas id="tutorial" width="600" height="400"></canvas>
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    var img = document.querySelector("img");
    ctx.drawImage(img, 0, 0);
}
document.querySelector("img").onclick = function (){
    draw();
}
```

##### 7. 变形
translate(x, y)   // 移动      
rotate(angle)     // 旋转            
scale(x, y)       // 缩小放大               
transform(a, b, c, d, e, f)   // 变形矩阵     

##### 8. 裁剪
```
var ctx;
function draw(){
    var canvas = document.getElementById('tutorial1');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
 
    ctx.beginPath();
    ctx.arc(20,20, 100, 0, Math.PI * 2);
    ctx.clip();   // 裁剪
 
    ctx.fillStyle = "pink";
    ctx.fillRect(20, 20, 100,100);
}
draw();
```

##### 9. 状态的保存和恢复
save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。         
1、关于 save() ：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。           
2、关于restore()：每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复(类似数组的 pop())。         


##### 10. 合成
```
// 默认新图形覆盖上一个图形，但仅有这个形式是不够的

globalCompositeOperation = "source-over";    // 覆盖之前的，默认
globalCompositeOperation = "source-in";      // 仅显示新图像重叠部分
globalCompositeOperation = "source-out";     // 仅显示新图像没有重叠部分
globalCompositeOperation = "source-atop";    // 显示老图像及新图像和老图像重叠部分
globalCompositeOperation = "destination-over";    // 新图像在老图像下边
globalCompositeOperation = "destination-in";       // 仅显示老图像重叠部分
globalCompositeOperation = "destination-out";      // 仅显示老图像没有重叠部分
globalCompositeOperation = "destination-atop";     

globalCompositeOperation = "lighter";    // 新老图像都显示，重叠部分颜色特殊处理
globalCompositeOperation = "darken";     // 保留重叠部分最黑的像素
globalCompositeOperation = "lighten";    // 保留重叠部分最量的像素
globalCompositeOperation = "xor";        // 重叠部分变透明 
globalCompositeOperation = "copy";       // 只保留新图像

<body>
    <canvas id="tutorial1" width="150" height="150"></canvas>
<script type="text/javascript">
    function draw1(){
        var canvas = document.getElementById('tutorial1');
        if (!canvas.getContext) return;
        var ctx = canvas.getContext("2d");
     
        ctx.fillStyle = "blue";
        ctx.fillRect(0, 0, 100, 100);
     
        ctx.globalCompositeOperation = "source-over"; //全局合成操作
        ctx.fillStyle = "red";
        ctx.fillRect(80, 80, 50, 50);
    }
    draw1();
</script>
</body>
```


##### 11. 动画

动画步骤：     
1、clearRect()   // 清空 canvas。再绘制每一帧动画之前，需要清空所有         
2、save()        // 保存 canvas 状态             
3、绘制动画图形            
4、restore()     // 恢复 canvas 状态，在绘制完成一帧后            

```
<body>
<canvas id="solar" width="300" height="300"></canvas>
<script>
init();
// 1. 初始化画布
function init(){
    let canvas = document.querySelector("#solar");
    let ctx = canvas.getContext("2d");
    draw(ctx);
}
// 2. 请求动画
function draw(ctx){
    requestAnimationFrame(function step(){
        drawDial(ctx);     //绘制表盘
        drawAllHands(ctx); //绘制时分秒针
        requestAnimationFrame(step);  //闭环循环
    });
}
// 3. 绘制表盘
function drawDial(ctx){
    let pi = Math.PI;

    ctx.clearRect(0, 0, 300, 300); // 清除所有内容
    ctx.save();                    // 清除后保存最原始状态

    ctx.translate(150, 150);       // 坐标原点移动到原来的中心
    ctx.beginPath();
    ctx.arc(0, 0, 148, 0, 2 * pi); //x,y,r,绘制最外层圈
    ctx.stroke();
    ctx.closePath();

    for (let i = 0; i < 60; i++){  // 绘制刻度
        ctx.save();                // 每制作一刻度保存
        ctx.rotate(-pi / 2 + i * pi / 30);  //旋转坐标轴。坐标轴x的正方形从 向上开始算起
        ctx.beginPath();
        ctx.moveTo(110, 0);
        ctx.lineTo(140, 0);
        ctx.lineWidth = i % 5 ? 2 : 4;
        ctx.strokeStyle = i % 5 ? "blue" : "red";
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
    }
    ctx.restore();
}
// 4. 绘制时分秒针
function drawAllHands(ctx){
    let time = new Date();

    let s = time.getSeconds();
    let m = time.getMinutes();
    let h = time.getHours();

    let pi = Math.PI; // 180度
    let secondAngle = pi / 180 * 6 * s;  //计算出来s针的弧度
    let minuteAngle = pi / 180 * 6 * m + secondAngle / 60;  //计算出来分针的弧度
    let hourAngle = pi / 180 * 30 * h + minuteAngle / 12;  //计算出来时针的弧度

    drawHand(hourAngle, 60, 6, "red", ctx);       //绘制时针
    drawHand(minuteAngle, 106, 4, "green", ctx);  //绘制分针
    drawHand(secondAngle, 129, 2, "blue", ctx);  //绘制秒针
}
/*绘制时针、或分针、或秒针
 * 参数1：要绘制的针的角度
 * 参数2：要绘制的针的长度
 * 参数3：要绘制的针的宽度
 * 参数4：要绘制的针的颜色
 * 参数4：ctx
 * */
function drawHand(angle, len, width, color, ctx){
    ctx.save();
    ctx.translate(150, 150); //把坐标轴的远点平移到原来的中心
    ctx.rotate(-Math.PI / 2 + angle);  //旋转坐标轴。 x轴就是针的角度
    ctx.beginPath();
    ctx.moveTo(-4, 0);
    ctx.lineTo(len, 0);  // 沿着x轴绘制针
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.lineCap = "round";
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
}
</script>
</body>
```
![](../_static/html5_03_02-3.png)