## 1.05 面试: vue

```


1. vnode 是什么？
vnode：virtual dom，用js对象描述dom。
优点一：兼容性强，不受环境影响。
优点二：减少操作DOM，页面变化，通过vnode对比，对比过后挂载更新DOM
存放信息：
data 节点属性、elm 真实DOM节点、context上下文对象、isStatic是否静态.......


2. MVVM模式的理解？

它是一种设计思想，本质上是MVC的改进版。

M：model，业务操作的数据来源
V：view，视图界面
VM：viewmodel，view和model核心枢纽，vue.js

viewmodel的数据改变，会映射到view
view的内容改变，会映射到viewmodel

背景：
a. 早期我们都是操作更改DOM
b. 后来jquery提高了效率，但是还是大量的手动操作DOM
c. MVVM模式彻底解脱了，用户不操作DOM，将数据绑定到 viewmodel，在diff对比是否更新view。

MVC 是从v写入读取数据，c控制用户交互(解析数据)，m用来存放读取数据。
MVC 时代手机api数据简单，可以用C解析完成，但是随着数据复杂，C就变得臃肿，没有单独负责解析的。
于是就有了一个新类VM，VM解析数据，把结果给controller。

3. v-model 实现原理？
实现双线绑定，双向是指ViewModel中的data部分和View之间的双向关系。
正向：数据驱动页面
反向：页面更新数据

依赖ES的一个api Object.defineProperty (内部的get和set属性)
监听data变化，执行回调函数，声明view和data的关系，后续操作使用get和set属性
该方法是新定义或修改一个属性时，返回修改后的对象

4. vue 生命周期？
挂载阶段：
beforeCreate：data 事件都还没加载，不能获取dom节点
create：vue 实例已经创建，但不能获取 dom 节点，vue实例存在于js的变量，没开始渲染
beforeMount：创建根节点，不能获取所有DOM
mounted：组件绘制完成，页面渲染完毕，一般异步请求都写在这

更新阶段：
beforeUpdate：vue遵循数据驱动DOM的修改，该函数在数据更新后不立即更新数据，
update：DOM会和更改改过的内容同步

销毁阶段：
beforeDestory：
destory：

多组件生命周期：
挂载阶段：
父beforeCreate -> 父create -> 父beforeMount ->
子beforeCreate -> 子create -> 子beforeMount -> 子mount -> 父mount

更新阶段：
父createUpdate -> 子beforeUpdate -> 子Update -> 父Update

销毁阶段：
父beforeDestory -> 子beforeDestory -> 子destory -> 父destory


5. computed、watch、methods
computed 有缓存，data不变不会重新计算，提高性能。
methods 没有缓存，每次调用会重新计算

watch 侦听器当数据变化时，需要知执行某些操作，不需要返回值。
watch：是功能，多用于一个数据影响多个数据
computed：是属性，多用于一个数据受多个数据影响

6. 为何data必须是一个函数？
函数是引用类型，避免组件重用时导致数据相互影响。

7. ajax 请求应该放在哪个周期？
mounted 周期，js 是单线程的，ajax 异步获取，放在 mounted 之前没有用，只会让逻辑更混乱。


8. 多个组件有相同的逻辑，如何抽离？
用 mixin，定义一个js文件，把内容写到 export default内，然后在组件中import，放到mixin数组中。
同名优先级：混入 < 组件 < 实例
缺点：
多对多的关系，复杂度较高。变量来源不明，不利于阅读

9. 什么时候使用异步组件？
加载大的组件、路由异步加载

10. 什么时候用 beforedestory？
清楚自定义事件 event.$off、清楚定时器、解绑自定义事件(如windows scroll)

11. 插槽类型和特点？

具名插槽：使用name标识的 v-slot:title == #title ，不使用的叫匿名插槽
作用于插槽：父组件需要获取子组件中的值，子组件通过属性绑定值，父组件通过v-slot接收

12. action 和 mutation 区别？
action 处理异步操作，mutation不行。
action 可以整合多个mutatin，mutation 是原子操作。




13. 路由常用模式？
#hash
h5 history, 没有#，需要服务端支持

14. 如何配置路由异步加载(懒加载)？
即当路由被访问时才加载相应的页面。

正常：
import Login from "@/components/pages/signIn/signIn";
export default new Router({
  routes: [ {
      path: '/login',
      component: Login,
    }]
});

异步一：
routes: [ {
    path: '/login',
    component: resolve=>require(["@/components/pages/signIn/signIn"],resolve),
}]

异步二：
routes: [ {
    path: '/login',
    component: ()=>import("@/components/pages/signIn/signIn"),
}]

15. vuex 常见的性能优化方式？
合理的 v-show v-if keep-alived

自定义事件、DOM事件及时销毁
合理使用异步组件
data层级不要太深 (深度监听会一次性监听到底)
使用 vue-loader 在开发环境做模板编译(预编译)
使用 ssr
前端通用的性能优化
```

```
1. v-show vs v-if、v-show vs keepalived
v-show 应用 css display 控制显示和隐藏
v-if 是组件真正的渲染和销毁
频繁的切换建议用 v-show

一般简单的用 v-show 即可
keep-alived在vue框架层级进行js对象渲染
用户解决频繁切换组件的缓存，一般用于tab的切换


2. v-for 为什么用 key？
key 是 vue 中 vnode 的唯一标记，通过key，diff操作会更快更准确
也可以减少渲染次数，提高性能


5. 组件如何通讯？
父传子：props
子传父：$emit

其他关系：自定义事件

vuex 状态管理模式通信



```
